# Sage implementations of Algorithms 1 and 2

from sage.all import (RR, ZZ, GF, polygen, polygens, pari, prod, Set, next_prime, cputime, kronecker_symbol, hilbert_class_polynomial, Infinity, EllipticCurve, srange)
from sage.libs.pari.convert_sage import gen_to_sage
from sage.schemes.elliptic_curves.ell_finite_field import supersingular_j_polynomial
from sys import stdout

def AlgorithmOne(H, check_monic_irreducible=False, verbose=False):
    """ Returns 1 if H is a Hilbert class polynomial, 0 otherwise. """

    # optional check that input is monic and irreducible
    if check_monic_irreducible:
        if not H.is_monic() or not H.is_irreducible():
            return 0

    h = H.degree()
    rh = RR(h)
    lh = ((2.15*rh.log() + 4*((rh+2).log().log()+2).log() + 26.19)**2).floor()
    T = polygen(ZZ)
    X,Y = polygens(ZZ,'XY',2)
    H = H.change_ring(ZZ)(T)
    Fq = GF(101)
    Tq = polygen(Fq);
    Xq,Yq = polygens(Fq,['Xq', 'Yq'],2)
    Hmodq = H.change_ring(Fq)
    HYq = H(Yq)
    l = ZZ(2)
    while True:
        l = l.next_prime()
        if l > lh:
            print("Exceeded GRH bound l(h)={}, terminating".format(lh))
            return 0
        Hl = H.change_ring(GF(l))
        if not Hl.is_squarefree():
            continue
        if Hl.parent()(supersingular_j_polynomial(l)).divides(Hl):
            continue
        if verbose:
            print("Using l={}".format(l))
        phi = gen_to_sage(pari.polmodular(l),{'x':X,'y':Y})
        res = phi([Xq,Yq]).resultant(HYq,Yq)([Tq,0])
        quo, rem = res.quo_rem(Hmodq)
        if rem or not Hmodq.divides(quo):
            return 0
        res = phi.resultant(H(Y),Y)([T,0])
        quo, rem = res.quo_rem(H)
        if rem or not H.divides(quo):
            return 0
        return 1

def IsDiscriminant(D):
    r"""
    Returns True iff D is a discriminant.
    """
    return D in ZZ and D%4 in [0,1]

def FundamentalDiscriminant(D):
    r"""
    Given a discriminant D, returns the associated fundamental discriminant.
    """
    assert IsDiscriminant(D)
    D0 = D.squarefree_part()
    return D0 if D0%4==1 else 4*D0

def IsFundamentalDiscriminant(D):
    r"""
    Returns True iff D is a fundamental discriminant.
    """
    if not IsDiscriminant(D):
        return False
    if D%4:
        return D.is_squarefree()
    else:
        d = D//4
        return d%4 in [2,3] and d.is_squarefree()

def OrderClassNumber(D0,h0,f):
    r"""Given a fundamental discriminant D0 < 0 of class number h0=h(D0),
    and a conductor f returns the class number h(f**2 * D0) of the
    imaginary quadratic order of discriminant f**2 * D0
    """
    assert IsFundamentalDiscriminant(D0) and f > 0
    if f == 1:
        return h0
    ps = f.prime_divisors()
    n = (f // prod(ps)) * prod(p-kronecker_symbol(D0,p) for p in ps)
    if D0 == -3:
        assert h0 == 1 and n%3==0
        return n//3
    if D0 == -4:
        assert h0 == 1 and n%2==0
        return n//2
    return n*h0

def OnFloor(E,ell):
    r"""
    Returns True if a given ordinary E/Fq is on the floor of its ell-volcano and False otherwise
    """
    if ell == 2:
        return E.two_torsion_rank() < 2
    x = polygen(E.base_field())
    return len(gen_to_sage(pari.polmodular(ell),{'x':x,'y':E.j_invariant()}).roots()) <= ell

def HeightAboveFloor(E,ell,e):
    """Given ordinary E/Fq, a prime ell, and the height of the
    ell-volcano containing j(E) (which is the ell-adic valuation of
    the conductor the order generated by pi_E), returns the height of
    j(E) on its ell-volcano (which is the ell-adic valuation of the
    conductor of the order End(E))

    """
    if e == 0:
        return 0
    j = E.j_invariant()
    if j in [0, 1728]:
        return e
    s = 0 if OnFloor(E,ell) else 1
    if e <= 1 or s == 0:
        return s
    F = j.parent()
    x = polygen(F)
    X,Y = polygens(F,['X', 'Y'],2)
    phi = gen_to_sage(pari.polmodular(ell),{'x':X,'y':Y})
    j1 = phi([j,x]).roots(multiplicities=False)
    if len(j1) != ell+1:  # double roots can only happen at the surface
        return e
    if len(j1) < 3:
        return 0
    j0 = [j,j,j]
    h = 1
    while True:
        for i in range(3):
            r = (phi([j1[i],x])//(x-j0[i])).roots(multiplicities=False)
            if not r:
                return h
            j0[i] = j1[i]
            j1[i] = r[0]
        h += 1

def End13(E,h):
    """Given an ordinary elliptic curve E/Fp and in integer h, returns
    D=disc(End(E)) assuming h(D)=h, using the approach sketched in
    Remark 13.  If the algorithm returns 0 it means that it has proved
    that h(D) != h, but it is under no obligation to do so and is
    allowed to return any value when the assumption h(d)=h is false.
    """
    p = E.base_field().cardinality()
    assert p != Infinity
    ap = E.trace_of_frobenius()
    assert ap%p
    D1 = ap**2 - 4*p
    D0 = FundamentalDiscriminant(D1)
    v = ZZ(D1//D0).isqrt()
    assert D1 == v**2*D0
    h0 = D0.class_number()
    if h%h0:
        return 0
    cs = [v//f for f in v.divisors() if OrderClassNumber(D0,h0,f) == h] # cofactors c=v/f compatible with h(f**2D0)=h
    if not cs:
        return 0
    if len(cs) == 1:
        return (v//cs[0])**2 * D0
    L = sorted(list(Set(sum([c.prime_factors() for c in cs], []))))
    for ell in L:
        e = HeightAboveFloor(E,ell,v.valuation(ell))
        cs = [c for c in cs if c.valuation(ell) == e]
        if not cs:
            return 0
        if len(cs) == 1:
            return (v//cs[0])**2 * D0
    return 0

def AlgorithmTwo(H, check_monic_irreducible=False, verbose=False):
    """ Returns D if H is the Hilbert class polynomial H_D, 0 otherwise. """

    # optional check that input is monic and irreducible
    if check_monic_irreducible:
        if not H.is_monic() or not H.is_irreducible():
            return 0

    h = H.degree()
    h2list = [d for d in h.divisors() if (d-h)%2==0 and d.prime_to_m_part(2)==1]
    pmin = 33 * (h**2 * (RR(h+2).log().log()+2)**2).ceil()
    # Guarantees 4*p > |D| for fundamental D under GRH
    p = pmin-1
    n = 0
    while True:
        p = next_prime(p)  # Remark 11 is not applied here (this is asymptotically suboptimal)
        n += 1
        Hp = H.change_ring(GF(p))
        z = Hp.parent().quotient(Hp).gen()
        r = z**p-z
        d = r.lift().gcd(Hp).degree()  # number of roots mod p
        #assert d==len(Hp.roots())
        if d==0:
            continue
        if not Hp.is_squarefree():
            continue
        if d<h and d not in h2list:
            return 0
        jp = Hp.any_root(degree=-1, assume_squarefree=True)
        E = EllipticCurve(j=jp)
        if E.is_supersingular():
            continue
        if verbose:
            print("Found a suitable prime p = {} after testing {} primes\n".format(p, n))
        D = End13(E,h) # Apply Remark 13
        if D == 0:
            return 0
        hilbert_class_polynomial.clear_cache()
        return D if H == hilbert_class_polynomial(D) else 0

D1000 = [-d for d in srange(3,1001) if d%4 in [0,3]]
assert len(D1000) == 500

AbelianD1 = [-3, -4, -7, -8, -11, -12, -16, -19, -27, -28, -43, -67, -163]
AbelianD2 = [ -15, -20, -24, -32, -35, -36, -40, -48, -51, -52, -60, -64, -72, -75, -88, -91, -99, -100, -112, -115, -123, -147, -148, -187, -232, -235, -267, -403, -427]
AbelianD4 = [ -84, -96, -120, -132, -160, -168, -180, -192, -195, -228, -240, -280, -288, -312, -315, -340, -352, -372, -408, -435, -448, -483, -520, -532, -555, -595, -627, -708, -715, -760, -795, -928, -1012, -1435 ]
AbelianD8 = [ -420, -480, -660, -672, -840, -960, -1092, -1120, -1155, -1248, -1320, -1380, -1428, -1540, -1632, -1848, -1995, -2080, -3003, -3040, -3315 ]
AbelianD16 = [ -3360, -5280, -5460, -7392 ]
AbelianD = AbelianD1 + AbelianD2 + AbelianD4 + AbelianD8 + AbelianD16
assert len(AbelianD) == 101

# [least,median,largest] discriminants of class number 5,10,15,...,100
hD100 = [[-47,-571,-2683],[-119,-2299,-13843],[-239,-6571,-34483],[-455,-9124,-58843],[-479,-25747,-93307],[-671,-21592,-137083],[-1031,-42499,-210907],[-1271,-34180,-274003],
         [-1319,-60748,-308323],[-1799,-64203,-389467],[-4463,-101419,-452083],[-2159,-83176,-662803],[-3527,-138883,-703123],[-3239,-138979,-821683],[-4703,-157051,-916507],
         [-5183,-133620,-1165483],[-4079,-252988,-1285747],[-5951,-204619,-1548523],[-6959,-251443,-1659067],[-7991,-249451,-1856563]]
assert len(hD100) == 20

# [least,median,largest] fundamental discriminants of class number 125,150,175,...,1000
hD1000 = [[-11519,-570139,-2944363],[-11879,-658891,-4163443],[-18719,-1124131,-4742467],[-21311,-984952,-7206763],[-25031,-1911787,-9119203],[-30551,-1881987,-12208267],[-38351,-2682227,-14420323],
           [-34271,-2497819,-19184323],[-38639,-3414379,-19385683],[-47759,-3724003,-24669283],[-53231,-5552779,-26809843],[-67031,-3890859,-32492923],[-84719,-6756619,-35307787],
           [-75599,-6503512,-40868683],[-99839,-8428291,-43078963],[-96599,-6895428,-53698747],[-117911,-9473059,-51065683],[-127151,-9325347,-69758203],[-136751,-11505827,-61595227],
           [-148511,-9248548,-72789403],[-234599,-13993459,-81289723],[-227015,-13278259,-85527187],[-269879,-17452579,-104367187],[-185471,-13972667,-96016243],[-226799,-19566907,-106911667],
           [-218951,-17530243,-113620123],[-265079,-21602923,-134009467],[-233999,-15304228,-129667987],[-316391,-24836347,-130788067],[-266279,-23348968,-135386227],[-250799,-27051163,-149457163],
           [-299519,-22973988,-180619363],[-314159,-30598123,-164446027],[-351911,-28525507,-186089443],[-376631,-35460091,-184039507],[-412079,-25671795,-220287043]]
assert len(hD1000) == 36

def CMProfile(alg, discs, exact=True, detail=1):
    start = cputime()
    # x = polygen(ZZ)

    if detail == 3:
        print("\\begin{tabular}{rrrrrrr}\n$h$ & $|H|$ & $D$ & $t_{\\rm HCP}$ & $t_{\\rm CM}$ & $t_{\\rm noCM}$\\\\\\toprule")
    else:
        print("Computing H_D and checking H_D(x),H_D(x)+1) for {} discriminants".format(len(discs)))

    for D in discs:
        t0 = cputime()
        hilbert_class_polynomial.clear_cache()
        H = hilbert_class_polynomial(D)
        t0 = cputime()-t0
        t1 = cputime()
        assert (alg(H) == D if exact else alg(H) != 0)
        t1 = cputime()-t1
        # t2 = cputime()
        # assert alg(H(x+1)) == 0
        # t2 = cputime()-t2
        t3 = cputime()
        assert alg(H+1) == 0
        t3 = cputime()-t3
        h = H.degree()
        ht = max(abs(c) for c in H).log().round()
        if detail==1:
            print(".", end="")
            stdout.flush()
        elif detail==2:
            print("h={}, |H|={}, D={}: {:.2f}s, {:.2f}s, {:.2f}s".format(h,ht,D,t0,t1,t3));
        elif detail==3:
            print("{} & {} & {} & {:.2f} & {:.2f} & {:.2f}\\\\".format(h,ht,D,t0,t1,t3))

    if detail == 1:
        print()
    if detail == 3:
        print("\\bottomrule\n\\end{tabular}")

    print("Verified {} discriminants in {:.3f}s".format(len(discs), cputime()-start))

# display usage instruction on loading this file

print("Example usage:")
print("CMProfile(AlgorithmTwo,[r[2] for r in hD100], detail=3)")
print("or")
print("CMProfile(AlgorithmOne,[r[2] for r in hD100], exact=False, detail=2)")
